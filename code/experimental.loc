foo :: Int -> Foo {a :: Int, b :: Str};


-- typedefs are type constructors or aliases.

typedef Name = Str

-- they may by language-specific
typedef py Name = str
typedef cpp Name = "std::string"
typedef r Name = "character"

-- types with constraints
typedef Age = x:Int where {x >= 0}

-- dependencies on other record types
typedef DNAFasta = PairList Str DNA

-- type functions
typedef (PairList key val) = [(key, val)]


-- records
record Person = Person { name :: Name, age :: Age }

-- they can also be unnamed
record PersonPos = PersonPos Name Age

-- record extensions
record Child = Person + {gaurdians :: [Person]}

-- language-specific records where record fields are constructor arguments
record Cpp PersonObj = "Person" { name :: "std::string", age :: int }

-- there may be multiple language-specific types for a given general one
record Py PersonObj = "Person" { name :: str, age :: int }
record Py PersonDict = "dict" { name :: str, age :: int }

-- may be recursive
record (RoseTree a) = RoseTree { value :: a, children :: [RoseTree a] }
record Py (RoseTreeDict a) = "dict" { value :: a, children :: [RoseTreeDict a] }

-- language-specific
munge :: RoseTree Person -> [Name]          -- using `record Name = Str`
munge py :: RoseTreeObj PersonObj -> [Name] -- using `record py Name = str`

-- changing order and key name, for python this isn't necessary, since the
-- constructor would be passed keyword arguments.
record Py (RoseTreeObj a) = "Tree" {
    children as "kids" :: [RoseTreeObj a]
  , value as "payload" :: a }

-- -- python constructor
-- RoseTreeObj(kids=children, payload=value)

-- constructing an record from a parameterized type
record (RoseTree2 a) = RoseTree2 a [RoseTree a]
record Py (RoseTreeObj2 a) = RoseTree a [RoseTreeDict2 a]
constructor Py (RoseTreeDict a) = "RoseTree(kids=$2, payload=$1, depth=0)"

-- but many types cannot be described as a function of instances of their
-- parameters, for example Map, below:
record (Map a b) = Map a b
-- where the argument to the function is probably something like: [(a,b)]. Map would need a dedicated




record Cpp (PairList key val) = ["std::pair<$1,$2>" key val]
record Cpp (Tuple2List key val) = ["std::tuple<$1,$2>" key val]

olderThan :: Int -> [Person] -> [Person]
olderThan py :: int -> [PersonDict] -> PersonDict
olderThan py :: int -> [PersonObj] -> PersonObj
