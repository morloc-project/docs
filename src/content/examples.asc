
=== Hello world!

[source, morloc]
----
module main (hello)
hello = "Hello World"
----

Here a module named `main` is defined that exports the term `hello` which is
assigned the string value of "Hello World".

Paste this into a file (e.g. "hello.loc") and then it can be imported by other
`morloc` modules or directly compiled into a program where every exported term
is a subcommand.

[source, shell]
----
morloc make hello.loc
----

This will generate a single file named "nexus.py". The nexus is the executable
script that the user will interact with. For this simple example, it is the
only generated file. It is currently written in Python. 

Calling "nexus.py" with no arguments or with the `-h` flag, will print a help
message:

[source, shell]
----
$ ./nexus.py -h
The following commands are exported:
  hello
    return: Str
----

The command is called as so:

[source, shell]
----
$ ./nexus.py hello
Hello World
----

=== Single language function composition

The following code uses only C++ functions (`fold`, `map`, `add` and `mul`). 

[source, morloc]
----
module main (square, sumOfSquares)

import cppbase (fold, map, add, mul)

square x = mul x x

sumOfSquares xs = fold add 0.0 (map square xs)
----

If this script is pasted into the file "example-1.loc", it can be compiled as
follows:

[source, shell]
----
morloc install cppbase
morloc make example-1.loc
----

The `install` command clones the `cppbase` repo from github into the
local directory `~/.morloc/lib`. The `make` command will generate a file named
`nexus.py`, which is an executable interface to the exported functions.

You can see the exported functions and the number of arguments they take:

[source, shell]
----
$ ./nexus.py
The following commands are exported:
  square
    param 1: Real
    return: Real
  sumOfSquares
    param 1: List Real
    return: Real
----

Then you can call the exported functions:

[source, shell]
----
$ ./nexus.py sumOfSquares [1,2,3]
14
----

The `nexus.py` executable dispatches the command to the compiled C++ program, `pool-cpp.out`.


=== Composition between languages

`morloc` can compose functions across languages. For example


[source, morloc]
----
module main (fibplot)

import math (fibonacci)
import rbase (plotVectorPDF, ints2reals)

fibplot n = plotVectorPDF (ints2reals (fibonacci n)) "fibonacci-plot.pdf"
----

The `fibplot` function calculates Fibonacci numbers using a C++ function and
plots it using an R function.

`plotVectorPDF` is defined in the `morloc` module `rbase` (https://github.com/morloclib/rbase). The `morloc` module
contains the following files:

```
README.md
package.yaml
main.loc
core.R
rbase.R
```

The `main.loc` file contains `morloc` function signatures, compositions, and
export statements. The `core.R` and `rbase.R` files contain R source code.
`rbase.R` contains the general serialization functions required for R
interoperability with other languages. The `core.R` file contains mostly core
utilities that are common between languages (`map`, `zip`, `fold`, `add`,
`sub`, etc). `ints2reals` is an alias for the base R function `as.numeric`.
`plotPDF` is a wrapper around the generic R plot function, as shown below:

[source, r]
----
plotVectorPDF <- function(x, filename){
  pdf(filename)
  plot(x)
  dev.off()
}
----

This is a perfectly normal R function with no extra boilerplate. It takes an
arbitrary input `x` and a filename, passes `x` to the generic plot function,
and writes the result to a PDF with the name `filename`.

The `main.loc` file contains the type general type signature for this function:

[source, morloc]
----
plotVectorPDF :: [Real] -> Str -> ()
----

The first signature is the general type, the second is the concrete, R-specific
type.

Similarly the `fibonacci` `C++` function has the type:

[source, morloc]
----
fibonacci :: Int -> List Int
----

The general type, `Int -> List Int`, describes a function that takes an integer
and returns a list of integers. `List Int` could be written equivalently as
`[Int]`.

A concrete type signature can be inferred from the concrete signature but
evaluating type functions provided in the libraries:

[source, morloc]
----
type Cpp => Int = "int"
type Cpp => List a = "std::vector<$1>" a
----

After recursively applying these two type functions, the general type evaluates to the concrete type:

[source, morloc]
----
fibonacci :: "int" -> "std::vector<$1>" "int"
----

`"std::vector<$1>" "int"` aligns to `List Int` (or equivalently, `[Int]`). The
type that is used in `C++` prototypes and type annotations is generated from the
concrete type via macro expansion into the type constructor: `int` replaces `$1`
yielding the concrete type `std::vector<int>`.

The fibonacci function itself is a normal C++ function with the prototype: 

[source, cpp]
----
std::vector<int> fibonacci(int n)
----
