
=== Type inference

Every sourced function in `morloc` must be given a general type signature. These
are usually the only type annotations that are needed in a `morloc`
program. Types of all other expressions in the program can be inferred. But this
type inference gives us only the general types of all expressions. In order to
generate code and properly (de)serialize when needed, we must know the
language-specific type of every expression. The transformation from general type
to concrete type is performed using user provided type functions. For example:

[source, morloc]
----
type Cpp => Map a b => "std::map<$1,$2>" a b
type Cpp => Tuple2 a b => "std::tuple<$1,$2>" a b
type Cpp => List a => "std::vector<$1>" a
type Cpp Int = "int"
type Cpp Str = "std::string"

source Cpp from "foo.hpp" ("listToMap", "strLen", "map")

listToMap :: [(a,b)] -> Map a b
strLen :: Str -> Int
map :: (a -> b) -> [a] -> [b]

makeLengthMap xs = listToMap . map (\x -> (x, strLen x))
----

The sourced function `listToMap`, `strLen`, and `map` all require general type
signatures. From these general type signatures, the type of every sub-expression
in `makeLengthMap` can be inferred, so this function does not need a type
signature. Its type is: `[Str] -> Map Str Int`.

There are currently a small number of special types in `morloc`. Among these are
the primitives `Int`, `Real`, `Bool`, `Str`, and `Unit`. The `Int` is an integer
of unlimited size. The `Real` is a float of unlimited precission and
width. These two types correspond to the integers and reals that are allowed in
JSON. The `Str` is currently limited to ASCII. The reason for this is partly my
bias from scientific computing, where ASCII is usually all we need (there are no
umlauts in DNA sequence). I will extend support eventually. The `Unit` type
corresponds to the JSON `null`. The other special types are `List` and `TupleX`,
where `X` is any integer greater than 2.

The `Int` and `Real` types can be thought of as mathematical ideals. Int
contrast, the `C++` `int` and `double` types are more limited. When the
deviations from the ideal integer and real numbers matter, more specific general
types may be created, such as `BigInt`, `Int32`, or `Float64` types, for
integers of unlimited size, 32 bits intgers, or 64 bit floats, respectively.

The `Map` type, is not special in `morloc`. To define a new type, either `Map`
or `BigInt`, you have to tell `morloc` how the type can be broken down into
simpler components (see the next section on Serialization).


=== Serialization

`morloc` 's current interoperability paradigm is based entirely on
serialization. Serialization is not a fundamental requirement of
`morloc`. JSON serialization could be replaced with machine-level
interoperability for a pair of languages. This change would be invisible to
`morloc` programmers, since serialization interop is handled by the compiler.

Data types that have an unambiguous mapping to the JSON data model can be
automatically serialized without special handling added by the programmer. The
JSON data model follows this grammar:

```
json : number
     | bool
     | string
     | null
     | [json]
     | {label : json, ...}
```

Types that are compositions of primitives and containers can be automatically
serialized. This includes records and the subset of objects for which arguments
passed to the constructor are asigned to accessible fields. For other types, an
(un)packing function that simplifies the data is required. For example, take the
general type `Map a b`, which maps keys of type `a` to values of type `b`. In a
given language, the `Map` type may be implemented as a hash table, a tree, pair
lists, or even a connection to a database. The types `a` and `b` do not give
enough information to serialize the object. Therefore, the user must provide an
unpack function which could be `Map a b -> ([a],[b])` or `Map a b -> [(a,b)]`
while the pack function work in the opposite direction. These functions are
provided in an instance of the `Packable` type class, for example: 


[source, morloc]
----
module map (Map)

type Cpp => Map a b = "std::map<$1,$2>" a b

class Packable a b where
  pack :: a -> b
  unpack :: b -> a

instance Packable ([a],[b])  (Map a b) where
  source Cpp "map.hpp" ("packMap" as pack, "unpackMap" as pack)
----


Note that the unpack function `Map a b -> ([a],[b])` does not necessarily take
us all the way to a serializable form since `a` and `b` may be arbitrarily
complex objects. This is no problem, `morloc` will recursively handle
(de)serialization all the way down.


== Creating types

What if we wanted to define the whole group of standard data structures, for
example:


----
type Cpp => Array a => "std::array<$1>" a
type Cpp => Vector a => "std::vector<$1>" a
type Cpp => LinkedList a => "std::list<$1>" a
type Cpp => Stack a => "std::stack<$1>" a
----


This can be done. A pair `Packable` instance may be defined for each type. At
the moment, the `[...]` syntax would not work for these data structures. And
what if we want to write functions that work across any of them? Such as
`length` or `map`? What we need is ad hoc polymorphism, i.e., typeclasses.


----
instance Functor (Array a) where
  map :: (a -> b) -> Array a -> Array a

instance Foldable (Array a) where
  foldl 
  foldr


instance Packable a b where
  pack :: a -> b
  unpack :: b -> a

type (Maybe a)

class HasEmpty a where
  empty :: a

class (HasEmpty f, Functor f, Foldable f) => OrderedSet f where
  insert :: a -> f a -> f a

type (Maybe a)


_ :: (a -> b) -> f a -> f b
_ :: (a -> b -> b) -> b -> f a -> b
_ :: f a              -- empty element
_ :: f a -> (a, f a)  -- first and remainder
_ :: f a -> (f a, a)
_ :: a -> f a -> f a
_ :: f a -> a -> f a
_ :: a -> a -> a

instance Semigroup a where
  (<>) :: a -> a -> a
----
