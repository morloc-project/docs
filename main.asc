= Morloc Technical Manual
:source-highlighter: pygments
:pygments-style: emacs
:imagesdir: images
:includedir: sections
:stem: latexmath
:sectnums:
:bibtex-file: references.bib
:bibtex-style: cambridge-university-press-numeric.csl
:bibtex-order: appearance
:toc: left

[NOTE]
This document is cobbled together from loose informal notes, fragments of an
out-of-date academic paper, and purple prose from an NSF grant. Much of what is
written here has not yet been implemented and much of what has been implemented
will be changed in the future.


Morloc is a framework that allows interoperability between functions across
languages, multi-language libraries and package managers, and encoding of
domain specific behavior into the type system. Based on this framework, we will
build a community portal for curating a universal library. Any public functions
in this library can be used in any Morloc script. They may also be imported
into specific languages and used.

The ultimate purpose of the Morloc system is to serve as the foundation for a
universal library of functions. Each function in the library has a universal
type that specifies how the function relates to other functions. Each function
has zero or more implementations. Each implementaton has a language-specific
type that aligns with the universal type. The Morloc compiler takes the
specification for a program, written as a compostion of typed functions, and
generates an optimized program.

In other words, Morloc is a query language that takes a program specification
and searches against a function database, returning an optimized composition of
functions. The functions may all be in the same language (often best for
performance when possible), or they may be from several languages.

`morloc` supports:

 * [x] function composition across languages (currently `C++`, R and Python3)

 * [x] higher-order functions

 * [x] currying

 * [x] generic types (System F) and type parameterization across languages

 * [x] type checking and inference

in development:

 * [ ] extensible records

 * [ ] a semantic type extension where types are defined in ontologies

 * [ ] dependent types (with cheats: if I can't solve statically, I'll generate optional assertion statements)

 * [ ] profanity-free error messages

 * [ ] a functional database and community portal (`morlocIO`)

 * [ ] a knowledgebase used to inform optimization in the compiler,  

 * [ ] automated testing of `morloc` functions

 * [ ] an actual userbase

 * [ ] much much more ...


= Introduction

I will introduce `morloc` first through a simple code example. Then discuss the
motivations for building the system.

include::{includedir}/examples.asc[]

include::{includedir}/motivation.asc[]

= Theory

include::{includedir}/types.asc[]

// system F - import the type specification

// ontology system

= Implementation

// system F

// generator and optimization

// the module system and environment

// // TODO: salvage the goods from this file (there is a lot of good)
// include::{includedir}/architecture.asc[]
// include::{includedir}/tech-tree.asc[]

= The Future

include::{includedir}/unsettled-issues.asc[]

include::{includedir}/pieces.asc[]

include::{includedir}/workflow.asc[]

= Related work

include::{includedir}/related-work.asc[]

[glossary]
= Glossary

include::{includedir}/glossary.asc[]

[appendix]

= LOC (old version of Morloc)

LOC was the first working(ish) version of `morloc` 

include::{includedir}/LOC.asc[]

[bibliography]
= References

bibliography::[]

// // flotsam
// include::{includedir}/old-letter.asc[]
//
// include::{includedir}/build-system.asc[]
//
// include::{includedir}/forms-of-data.asc[]
//
// include::{includedir}/function-roles.asc[]
//
// include::{includedir}/graph.asc[]
//
// include::{includedir}/manifolds-and-codegen.asc[]
//
// include::{includedir}/modules.asc[]
