== Motivation

The computer programming world is divided into insular communities centered
around specific programming languages. A function written in one language
cannot generally be used in another, this leads to costly reimplementation of
whole libraries. Further, there is also no general, inter-language method for
finding a function that performs a specific role. These problems slow the
development of analytic pipelines and hinder collaboration between communities.

The reason we are developing Morloc is to address these primary pain points:

. programming is tedious
. functions cannot be used across languages
. functions are not searchable
. cross-language abstractions are poor


=== Programming is tedious

While documentation, testing, checking, and package and system design are
seen as the tenants of "good programming", these are all "evils". They are
evil because they contribute nothing intrinsically to the purpose of
programming, which is either to ask a question and get an answer or to
animate a process. They are thought good only for the reasons death is
thought good.

Any work that is not part of the end. I distinguish here between the
"means" and the "ends". The "means" are tedious. The Morloc composer
should not have to deal with them. Rather, they describe the ends. They
describe the input data. They describe the serious of transformations that
may be done upon it. Then the compiler builds the program. And the
composer interacts with it however they like.

From the programmer's point of view, "tedious work" is anything that is
not part of the transformation from inputs to outputs. Checking the
inputs, testing and benchmarking, internal infrastructure, package
infrastructure, most documentation, writing input and output, handling
caching, handling runtime environment, handling parallelism.

=== Functions cannot be used across languages

A second problem is the complexity of using functions across languages.
This problem is especially vexing for high-turnover analyses, where there
is a constant flow of wildly different problems, requiring tools from
dozens of fields, and reading data in all manner of forms and formats. One
solution is to program pipelines where each function is wrapped as an
executable and then called from a master language. This is the approach
taken by Galaxy and the whole Make-family of rule-based languages. However,
this suffers from bloated code.

Inter-language interfacing can require some of the most tedious coding
imaginable. Let's say we have two functions, f and g, from two different
languages. To connect them we have to 1) write a wrapper around f that
converts the output of f to a language-agnostic file that g understands
(e.g. csv, JSON, XML), 2) write a wrapper around g that tries to open this
file (with read error handling), 3) convert the raw binary data into the
internal form g needs, 4) write code to assert the input to g is correct,
and 5) inform the master program of any failure. The programmers of f and
of g have to agree on two conventions: a common intermediate formats and
a way to pass error. This approach is so tedious and error prone that
sensible people avoid multi-language systems.

This barrier between languages causes languages communities to become
highly insular. Every problem has to be reimplemented in every language.
For example, we have Bioperl, Biopython, Bioconductor (R), Biojava, etc.
Also this places new languages, with few libraries, at a disadvantage, and
thus slows the evolution of programming.

=== Functions are not searchable

The final problem is that searching for functions is annoyingly difficult.
Within in a specific strongly-typed language, you may be able to search by
function signature. Within dynamic languages you are limited to text
searches against the documentation or unchecked, hand-written type
annotations. Searching for functions across languages is an unsolved (and
usually unasked) question. The best we can do is query Google and hope the
terms are written in the documentation.

While all of this is tedious for humans, it is all but impossible for
machines. We have written trillions of lines of code and millions of
functions, but only humans can use them. We have built elaborate systems
for searching data, powerful algorithms for reasoning on data,
specifications and formats for passing data, but for functions we have
nothing. Machines cannot reason about or use our tools.

=== Cross-language abstractions are poor
