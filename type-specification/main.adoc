= xi experimental type system
:source-highlighter: pygments
:pygments-style: emacs
:bibtex-file: references.bib
:bibtex-style: cambridge-university-press-numeric.csl
:bibtex-order: appearance

The type system presented below is based on the one developed be Dunfield and
Krishnaswami cite:[dunfield2013complete] (DK). I preserved their naming
conventions where possible.

[env.texmacro]
--
\def\ea{\widehat{\alpha}}
\def\eb{\widehat{\beta}}
\def\eg{\widehat{\gamma}}
\def\sep{ \quad\quad}
\newcommand{\mark}[1]{\blacktriangleright_{#1}}
\newcommand{\expr}[3]{#1\ \ \vdash\ #2\ \dashv\ \ #3}
\newcommand{\packto}[2]{#1\ \approx >\ #2}
\newcommand{\apply}[3]{#1 \bullet #2\ \Rightarrow {\kern -1em} \Rightarrow\ #3}
\newcommand{\subtype}[2]{#1\ :\leqq\ #2}
\newcommand{\braced}[1]{\lbrace #1 \rbrace}
--

== Grammar

[env.equationalign]
--
program   &\ :\ [statement]                         \sep & \text{brackets indicate a list of 0 or more} \\
statement &\ :\ \text{Source}\ x\ L                 \sep & \text{source var x from language L} \\
          &\ |\ \text{Import}\ v\ L                 \sep & \text{source var x from language L} \\
          &\ |\ \text{Export}\ x                    \sep & \text{source var x from language L} \\
          &\ |\ x\ L ::\ A                          \sep & \text{signature for language L} \\
          &\ |\ x=expr\                             \sep & \text{declaration} \\
expr      &\ :\ (\ )                                \sep & \text{nothing} \\
          &\ |\ x                                   \sep & \text{var} \\
          &\ |\ x\ ::\ [(L, A)]                     \sep & \text{annotation, usually only used in annotated output} \\
          &\ |\ \lambda x .\ expr                   \sep & \text{abstraction} \\
          &\ |\ expr\ expr                          \sep & \text{application} \\
          &\ |\ num\ |\ str\ |\ bool                \sep & \text{primitives} \\
          &\ |\ [e_1, ..., e_n]                     \sep & \text{list} \\
          &\ |\ (e_1, ..., e_n)                     \sep & \text{tuple} \\
          &\ |\ \braced{v_1=e_1,\ ...,\ v_n = e_n}  \sep & \text{record}
--

Xi departs from conventional lambda calculus by supporting multiple languages
in one program. Xi is designed to typecheck programs comprised of many
languages that share a common general type but that also have language-specific
forms. Thus an expression may have the abstract type `Num` and the C-type
`double` and the python type `float`. Top-level signatures can be used to
specify the type of a term in different languages. A term may be sourced from
many different languages, thus $x$ is multilingual.

[env.equationalign]
--
\text{Types} \sep A,B,C\ &:= 1     \sep & \text{unit} \\
       &|\ \alpha_L                \sep & \text{var in language L} \\
       &|\ A \rightarrow B         \sep & \text{function} \\
       &|\ \forall\ \alpha_L\ . A  \sep & \text{universal quantification over L} \\
       &|\ \alpha_L\ [A]           \sep & \text{parameterization} \\
--

Every type is associated with either the general language or a concrete
realization of the general type into a specific language.

|===
<| $\text{TypeAnnotation} \sep A^{\bullet}, B^{\bullet}, C^{\bullet}\ := A \; L \; \braced{P_i}_{i=0}^m \; \braced{C_i}_{i=0}^n$
   +
   $\text{Typeset} \sep \vec{A} := A_1^{\bullet},\ ...,\ A_n^{\bullet}$
|===

Type annotations couple a type to properties, a language (possibly the general
one), and constraints. Typesets serve as collections of all that is known about
a type as it is represented across languages. Different languages may have
different sets of properties and constraints, they are unified only by a common
name and complete interchangeability.

== Let polymorphism

We depart from Hindley-Milner (HM) by excluding a +let+ term. In HM,
expressions bound in +let+ are generalized, allowing statements such as:

----
let f = (forall a . a -> a) in
    x = (f 42, f "lettuce")
----

Where $f$ is generalized, allowing it to retain its polymorphism. The same is
not true of variables bound in functions (in HM at least). For example, the
following Haskell expression fails to typecheck:  

----
foo :: (a -> a) -> (Int, String)
foo f = (f 42, f "lettuce")
----

We do not suport +let+ expressions or _let-polymorphism_, instead we generalize
expressions only if they are bound at the top-level (i.e. in +declaration+
terms). This follows the practice argued for in cite:[vytiniotis2010let].

== Declarative type system

== Algorithmic Rules

=== Context

[env.equationalign]
--
\Gamma, \Delta & \ :\ [entry]              \sep & \text{ordered list of }entry \text{ items} \\
entry          & \ :\ \alpha_L             \sep & \text{type variable from language L} \\
               & \ |\ e = \vec{A}          \sep & \text{annotated expression}          \\
               & \ |\ \ea_L                \sep & \text{existential}                   \\
               & \ |\ \ea_L = t            \sep & \text{solved existential}            \\
               & \ |\ \mark{x}             \sep & \text{a named marker}                \\
               & \ |\ \text{Source}\ v\ L\ \sep & \text{source term from language L}   \\
               & \ |\ \text{Export}\ v     \sep & \text{export term v from this module}
--

The context is a list storing type annotations, solved and unsolved existential
variables, markers, and source/export info.

=== Subtyping and instantiation

The subtyping rules are adapted from DK.

There are two main extensions:
    
    1. multi-lingual support.

    2. Type application. This extension allows types to take an arbitrary
    number of type parameters. For example, the type of a hashmap from strings
    to integers might be written as +Map Str Int+. We also support +[a]+ as a
    shortcut for +List a+.

.Subtyping Rules
|===
<| $\expr{\Gamma}{A\ <:\ B}{\Delta}$ $\quad\quad$ Under input context $\Gamma$, type $A$ is a subtype of $B$, with output context $\Delta$
^| $\frac{}{\expr{\Gamma}{\alpha_L\ <:\ \alpha_L}{\Gamma}}$ [green]+<:Var+
   $\quad\quad$
   $\frac{\packto{\beta_{L2}}{\alpha_{L1}}}{\expr{\Gamma}{\alpha_{L1}\ <:\ \beta_{L2}}{\Gamma}}$ [blue]+<:AlienVar*+
   +
   + 
   $\frac{}{\expr{\Gamma}{\ea_L\ <:\ \ea_L}{\Gamma}}$ [green]+<:Exvar+
   $\quad\quad$
   $\frac{}{\expr{\Gamma}{\ea_{L1}\ <:\ \eb_{L2}}{\Gamma,\ \packto{\eb_{L2}}{\ea_{L1}}}}$ [blue]+<:AlienExvar*+
   +
   +
   $\frac{\Delta_1 = \Gamma \quad [\expr{\Delta_{i-1}}{A_i\ <:\ B_i}{\Delta_i}\]_{i=1}^n}{\expr{\Gamma}{\alpha_L\ [A_i\]_{i=1}^n <:\ \alpha_L\ [B_i\]_{i=1}^n}{\Delta_n}}$ [blue]+<:App+
   $\quad\quad$
   $\frac{\packto{\beta_{L2}\ [B_i\]_{i=1}^m}{\alpha_{L1}\ [A_i\]_{i=1}^n}}{\expr{\Gamma}{\alpha_{L1}\ [A_i\]_{i=1}^n\ <:\ \beta_{L2}\ [B_i\]_{i=1}^m}{\Gamma}}$ [blue]+<:AppAlien+
   +
   +
   $\frac{\packto{\alpha_{L1}\ [A_i\]_{i=1}^n}{\beta_{L2}}}{\expr{\Gamma}{\alpha_{L1}\ [A_i\]_{i=1}^n\ <:\ \beta_{L2}}{\Gamma}}$ [blue]+<:AppAlienVarL+
   $\quad\quad$
   $\frac{\packto{\alpha_{L1}}{\beta_{L2}\ [B_i\]_{i=1}^n}}{\expr{\Gamma}{\alpha_{L1}\ <:\ \beta_{L2}\ [B_i\]_{i=1}^n}{\Gamma}}$ [blue]+<:AppAlienVarR+
   +
   +
   $\frac{}{\expr{\Gamma}{1\ <:\ 1}{\Gamma}}$ [green]+<:Unit+
   $\quad\quad$
   $\frac{\expr{\Gamma}{B_1\ <:\ A_1}{\Theta} \quad \expr{\Theta}{[\Theta\]A_2\ <:\ [\Theta\]B_2}{\Delta}}{\expr{\Gamma}{A_1 \rightarrow A_2\ <:\ B_1 \rightarrow B_2}{\Delta}}$ [green]+<:→+
   +
   +
   $\frac{\expr{\Gamma,\mark{\ea_L},\ea_L}{[\ea_L/\alpha_L\]A\ <:\ B}{\Delta,\mark{\ea_L},\Theta}}{\expr{\Gamma}{\forall \alpha_L . A\ <:\ B}{\Delta}}$ [green]+<:∀L+
   $\quad\quad$
   $\frac{\expr{\Gamma,\alpha_L}{A<:B}{\Delta,\alpha_L,\Theta}}{\expr{\Gamma}{A <: \forall \alpha_L . B}{\Delta}}$ [green]+<:∀R+
   +
   +
   $\frac{\ea_L \notin FV(A) \quad \expr{\Gamma[\ea_L\]}{\subtype{\ea_L}{A}}{\Delta}}{\expr{\Gamma[\ea_L\]}{\ea_L\ <:\ A}{\Delta}}$ [green]+<:InstantiateL+
   $\quad\quad$
   $\frac{\ea_L \notin FV(A) \quad \expr{\Gamma[\ea_L\]}{\subtype{A}{\ea_L}}{\Delta}}{\expr{\Gamma[\ea_L\]}{A\ <:\ \ea_L}{\Delta}}$ [green]+<:InstantiateR+
>| $\text{subtype} :: A \rightarrow B \rightarrow \Gamma \rightarrow \Delta$
|===

Type variables in different languages have no subtype relationship. As far as
the typechecker goes, it is assumed that the language-specific (concrete) types
match if the general types do. Note that functions are not annotated with
languages. Thus the subtype test $A \rightarrow B\ <:\ \alpha_L$ and its reverse
will both raise errors.

The rule +<:AlienExvar+ stores in context an "existential assertion" that
cannot be evaluated until the existential variables it contains are solved.

.Instantiation Rules
|===
<| $\expr{\Gamma}{\subtype{\ea_L}{A}}{\Delta}$ $\quad\quad$ Under input context $\Gamma$, instantiate $\ea_L$ such that $\ea_L <: A$, with output context $\Delta$
^| $\frac{\Gamma\ \vdash\ \tau}{\expr{\Gamma,\ea_L,\Gamma'}{\subtype{\ea_L}{\tau}}{\Gamma,\ea_L=\tau,\Gamma'}}$ [green]+InstLSolve+
   $\quad\quad$
   $\frac{}{\expr{\Gamma[\ea_L\][\eb_L\]}{\subtype{\ea_L}{\eb_L}}{\Gamma[\ea_L\][\eb=\ea_L\]}}$ [green]+InstLReach+
   +
   +
   $\frac{\expr{\Gamma[\ea_2,\ea_1,\ea=\ea_2\rightarrow\ea_1\]}{\subtype{A_1}{\ea_1}}{\Theta} \quad \expr{\Theta}{\subtype{\ea_2}{[\Theta\]A_2}}{\Delta}}{\expr{\Gamma[\ea\]}{\subtype{\ea}{A_1 \rightarrow A_2}}{\Delta}}$ [green]+InstLArr+
   $\quad\quad$
   $\frac{\expr{\Gamma[\ea_L\],\beta_L}{\subtype{\ea_L}{B}}{\Delta,\beta_L,\Delta'}}{\expr{\Gamma[\ea_L}{\subtype{\ea_L}{\forall \beta_L . B}}{\Delta}}$ [green]+InstLAllR+
^| $\frac{\Gamma\ \vdash\ \tau}{\expr{\Gamma,\ea_L,\Gamma'}{\subtype{\tau}{\ea_L}}{\Gamma,\ea_L=\tau,\Gamma'}}$ [green]+InstRSolve+
   $\quad\quad$
   $\frac{}{\expr{\Gamma[\ea_L\][\eb_L\]}{\subtype{\eb_L}{\ea_L}}{\Gamma[\ea_L\][\eb_L=\ea_L\]}}$ [green]+InstRReach+
   +
   +
   $\frac{\expr{\Gamma[\ea_{L,2},\ea_{L,1},\ea_L=\ea_{L,2}\rightarrow\ea_{L,1}\]}{\subtype{\ea_{L,1}}{A_1}}{\Theta}  \quad  \expr{\Theta}{\subtype{[\Theta\]A_2}{\ea_{L,2}}}{\Delta}}{\expr{\Gamma[\ea_L\]}{\subtype{A_1 \rightarrow A_2}{\ea}}{\Delta}}$ [green]+InstRArr+
   $\quad\quad$
   $\frac{\expr{\Gamma[\ea_L\],\ \blacktriangleright \eb_L,\ \eb_L}{\subtype{[\eb_L/\beta_L\]B}{\ea_L}}{\Delta,\ \blacktriangleright \eb_L,\ \Delta'}}{\expr{\Gamma[\ea_L\]}{\subtype{\forall \beta_L . B}{\ea_L}}{\Delta}}$ [green]+InstRAllL+
>| $\text{instantiate}\ ::\ A \rightarrow B \rightarrow \Gamma \rightarrow \Delta$
|===

.Transform rules

|===
<| $\packto{A_{L1}}{B_{L2}}$ $\quad\quad$ Type $A$ in language $L1$ can be uniquely transformed to type $B$ in language $L2$ 
^| $\frac{}{\expr{\Gamma}{\packto{A_L}{A_L}}{\Gamma}}$ [green]+SerializeCis+
   $\quad\quad$
   $\frac {f\ L_1\ ::\ \text{packs}\ \Rightarrow\ A'_{L1}\ \rightarrow\ C_{L1} \quad g\ L_2\ ::\ \text{unpacks}\ \Rightarrow\ D_{L2}\ \rightarrow\ B'_{L2} \quad \subtype{A'_{L1}}{A_{L1}} \quad \subtype{B'_{L1}}{B_{L1}}} {\expr{\Gamma}{\packto{A_{L1}}{B_{L2}}}{\Gamma}}$ [green]+SerializeTrans+
   +
   +
   $\frac{f\ L\ ::\ \text{cast}\ \Rightarrow\ A_L\ \rightarrow\ X_L \quad \packto{X_L}{B_L}}{\expr{\Gamma}{\packto{A_{L}}{B_{L}}}{\Gamma}}$ [green]+Cast+
>| $\text{cast}\ ::\ A\ \rightarrow\ B\ \rightarrow\ \Gamma\ \rightarrow\ \Gamma$
|===

The transform rules assert that types are interconvertible. The serialization
rules transform between semantically equivalent types that are expressed in
different languages. The cast rules transform between semantically different
types expressed in the same language.

+SerializeCis+ is a trivial rule stating that any type can be converted to
itself. +SerializeTrans+ states that types $A_{L1}$ and $A_{L2}$ interconverted
if there exist functions for serializing from type $A$ in language $L_1$ to a
standard intermediate form (e.g., JSON) and a derserialization function from
the standard intermediate to $B$ in language $L_2$. The serialization function
may be more polymorphic than $A$ and $B$. For example, a general serialization
function may exist which would serialiaze any type in the given language into
JSON.

These assertions alone are not sufficient for proving that two types are
interconvertible. The serialization functions only show that a path exists
between the types, it does not show that the types are semantically equivalent.
Semantic equivalence is demonstrated through typechecking of the general,
language-independent, type. That is, if the language-specific types under
consideration are not semantically equivalent, and error will be raised
elsewhere in the typechecking process.

The +Cast+ rule involves handling of directed automatic conversions between
types within a language. A common example of this would be the conversion of
integers to doubles. The current rules are very strict, requiring type identity
for casting, and are not amiable to more general transformations. Note the rule
is recursive. The cast functions form a directed graph (usually highly
disconnected and possibly cyclic) of unambiguous and unfailing transformations
between types. They should describe relationships where there is a single
obvious meaning (e.g., +a->[a]+ or +PositiveInteger->Integer+) and that will
never fail (so string to integer would not be included).

Further, the rules specified here are assertions showing the transformations
are possible. There may be multiple paths to accomplishing the transforms that
will differ in performance and require different dependencies at build time.
Choosing which path to take is not the responsibility of the typechecker and
will be dependent on the user's system architecture and local configuration.


=== Typechecking rules -- bidirectional or tridirectional?

We add new typechecking rules that add support for primitives, containers,
declarations and signatures. The primitive rules are axioms where the types are
inferred by the lexer. The only currently supported container is a homogenous
list (e.g., +[Num]+ for a list of numbers). A declaration allows a variable to
be assigned to an expression. Top-level shadowing is not allowed (i.e. no
re-assignment). Also the types are generalized, with all remaining existential
variables pulled out as universal quantifiers.

.synthesize
|===
<| $\expr{\Gamma}{e \Rightarrow A}{\Delta}$ $\quad\quad$ Under input context $\Gamma$, $e$ synthesizes output type $A$, with output context $\Delta$
^| $\frac{\expr{\Gamma, x:A}{e_2\ \Rightarrow\ \\_}{\Delta}}{\expr{\Gamma}{x\ L\ ::\ A\ ;\ e_2}{\Delta}}$ [blue]+Signature+
   $\quad\quad$
   $\frac{}{\expr{\Gamma}{\text{Source }L\ x}{\Gamma,\ \ea_L}}$ [blue]+Source+
   +
   +
   $\frac{e\ \Rightarrow\ \\_\ \vdash\ \Theta \quad \lbrace x:A\ \|\ (x:A)\ \in\ \Theta \rbrace\ \vdash\ \Theta' \quad \lbrace x:A\ \|\ x\ \in\ xs,\ (x:A) \in \Theta' \rbrace\ \vdash\ \Delta}{\expr{\Gamma}{\text{Import}\ e\ xs}{\Gamma, \Delta}}$ [red]+Import+
   +
   +
   $\frac{x \notin \text{FV}(\Gamma) \quad \expr{\Gamma[x:A\], \mark{x}}{e\ \Leftarrow\ A}{\Delta,\mark{x}, \Theta}}{\expr{\Gamma}{x=e}{\Delta}}$ [blue]+DeclareCheck+
   $\quad\quad$
   $\frac{x \notin \text{FV}(\Gamma) \quad \expr{\Gamma,\mark{x}}{e\ \Rightarrow\ A}{\Delta,\mark{x}, \Theta}}{\expr{\Gamma}{x=e}{\Delta,\ x:\text{Gen}(A)}}$ [blue]+DeclareInfer+
>| $\text{synthesizeToplevel} :: \Gamma \rightarrow e \rightarrow \Delta$

^| $\frac{L = \text{MLang}}{\expr{\Gamma}{\text{number}\ \Rightarrow\ \text{Num}}{\Gamma}}$ [blue]+Num⇒+
   $\quad\quad$
   $\frac{L = \text{MLang}}{\expr{\Gamma}{\text{int} \Rightarrow \text{Int}}{\Gamma}}$ [blue]+Int⇒+
   $\quad\quad$
   $\frac{L = \text{MLang}}{\expr{\Gamma}{\text{string} \Rightarrow \text{Str}}{\Gamma}}$ [blue]+Str⇒+
   $\quad\quad$
   $\frac{L = \text{MLang}}{\expr{\Gamma}{\text{bool} \Rightarrow \text{Bool}}{\Gamma}}$ [blue]+Bool⇒+
   +
   +
   $\frac{L = \text{MLang} \quad \expr{\Gamma}{x_1 \Rightarrow A}{\Delta_1} \quad \expr{\Delta_1}{x_2 \Leftarrow A}{\Delta_2} \quad ... \quad \expr{\Delta_{n-1}}{x_n \Leftarrow A}{\Delta_n}}{\expr{\Gamma}{[x_1,x_2, ..., x_n\]}{\Delta_n,\ \text{List}\ A}}$ [blue]+List⇒+
   +
   +
   $\frac{L = \text{MLang} \quad \expr{\Gamma}{x_1 \Rightarrow A_1}{\Delta_1} \quad ... \quad \expr{\Delta_{n-1}}{x_n \Rightarrow A_n}{\Delta_n}}{\expr{\Gamma}{(x_1,x_2,\ ...\ x_n)}{\Delta_n,\ \text{Tuple}\ A_1\ ...\  A_n}}$ [blue]+Tuple⇒+
   +
   +
   $\frac{L = \text{MLang} \quad \expr{\Gamma}{x_1 \Rightarrow A_1}{\Delta_1} \quad ... \quad \expr{\Delta_{n-1}}{x_n \Rightarrow A_n}{\Delta_n}}{\expr{\Gamma}{\lbrace (k_1,x_1),(k_2, x_2),\ ...,\ (k_n, x_n) \rbrace}{\Delta_n,\ \lbrace (k_1, A_1),\ ...,\  (k_n, A_n) \rbrace}}$ [blue]+Record⇒+
   $\quad\quad$
   $\frac{L = \text{MLang}}{\expr{\Gamma}{() \Rightarrow 1}{\Gamma}}$ [green]+1l⇒+
   +
   +
   $\frac{L \quad \expr{\Gamma,\ea_L,\eb_L,x:\ea_L}{e \Leftarrow \eb_L}{\Delta, x:\ea_L, \Theta}}{\expr{\Gamma}{\lambda x.e\ \Rightarrow\ \ea_L\rightarrow \eb_L}{\Delta}}$ [green]+→I⇒+
>| $\text{synthesizeSingular} :: L \rightarrow \Gamma \rightarrow e \rightarrow (\Delta,\ A)$

^| $\frac{(\,x\,:\,A_L\,)\ \in\ \vec{A}\ \in\ \Gamma}{\expr{\Gamma}{x\ \overset{L}{\Rightarrow} A_L}{\Gamma}}$ [green]+Var+
   $\quad\quad$
   $\frac{\Gamma\ \vdash\ A \quad \Delta_1 = \Gamma \quad \braced{ \expr{\Delta_i}{e \overset{L_i}{\Leftarrow} A_i}{\Delta_{i+1}} }_{i=1}^k}{\expr{\Gamma}{(e:\vec{A})\ \Rightarrow\ \vec{A}}{\Delta}}$ [green]+Anno+
   +
   +
   $\frac{\expr{\Gamma}{e_1\ \Rightarrow\ \vec{A}}{\Delta} \quad\quad \braced{ \Delta\ \vdash\ [\Delta\] \apply{A_{L_i}}{e_2}{C_{L_i}}\ \|\ L_i \in \text{lang}(\vec{A}) }_{i=1}^k}{\expr{\Gamma}{e_1 e_2 \Rightarrow \vec{C}}{\Delta}}$ [green]+→E+
>| $\text{synthesizeSpread} :: \Gamma \rightarrow e \rightarrow (\Delta_k,\ [(L, A)\])$
|===

The three functions +synthesisToplevel+, +synthesisSingular+, and
+synthesisSpread+ are all specializations of the general functions of type:

`synthesis` +++::+++ +L+ -> +Gamma+ -> +e+ -> +[(L, A)]+


The top-level statements import/source terms, specify their type (+Signature+),
and build compositions from them (+Declaration+). A top-level declaration can
only ever be in MLang. An error should be raised if a concrete signature is
given.

Morloc Data structures can be typed into MLang, but not directly into other
languages without additional information. For example, is +[Num]+ in C++ an
array or vector? Is Num a "double" or a "float"? Determining the concrete type
will require a concrete type-signature. Thus the concrete types are _checked_
rather than _synthesized_.

Synthesizing a lambda requires we choose a language. Nothing in the body of the
lambda expression specifies the language of the lambda. The language of the
subcomponents may differ from the language of the lambda or may have no
concrete binding at all (e.g., $\lambda x . 42$).

The +Import+ rule is premised on the evalutation of $e$, which is an entire
module body that yields a full context. The term $A\ \Rightarrow\ \\_$ is an
inference that throws away the resulting type, being run only for the context
it generates.

+→E+ 

.check
|===
<| $\expr{\Gamma}{e \Leftarrow A}{\Delta}$ $\quad\quad$ Under input context $\Gamma$, $e$ checks against input type $A$, with output context $\Delta$ 
^| $\frac{}{\expr{\Gamma}{() \Leftarrow 1}{\Gamma}}$ [green]+1I+
   $\quad\quad$
   $\frac{\expr{\Gamma,x:A}{e \Leftarrow B}{\Delta,x:A,\Theta}}{\expr{\Gamma}{\lambda x.e \Leftarrow A \rightarrow B}{\Delta}}$ [green]+→I+
   $\quad\quad$
   $\frac{\expr{\Gamma,\alpha_L}{e \Leftarrow A_L}{\Delta,\alpha_L,\Theta}}{\expr{\Gamma}{e \Leftarrow \forall \alpha_L . A_L}{\Delta}}$ [green]+∀I+
   $\quad\quad$
   $\frac{\expr{\Gamma}{e \overset{L}{\Rightarrow} A_L}{\Theta} \quad\quad \expr{\Theta}{[\Theta\]A_L\ <:\ [\Theta\]B_L}{\Delta}}{\expr{\Gamma}{e \Leftarrow B_L}{\Delta}}$ [green]+Sub+
   $\quad\quad$
>| $\text{check} :: \Gamma \rightarrow e \rightarrow A \rightarrow (\Delta,\ B\])$
|===

.apply
|===
<| $\expr{\Gamma}{\apply{A}{e}{C}}{\Delta}$ $\quad\quad$ Under $\Gamma$, applying a function of type $A$ to $e$ synthesizes type $C$, with output context $\Delta$
^| $\frac{\expr{\Gamma[\ea_{2L},\ \ea_{1L},\ \ea_L\ =\ \ea_{1L}\ \rightarrow\ \ea_{2L}\]}{e \Leftarrow\ \ea_{1L}}{\Delta}}{\expr{\Gamma[\ea_L\]}{\apply{\ea_L}{e}{\ea_{2L}}}{\Delta}}$ [green]*latexmath:[\ea_L]*[green]+App+
   $\quad\quad$
   $\frac{\expr{\Gamma,\ea_L}{\apply{[\ea_L/\alpha_L\]A}{e}{C}}{\Delta}}{\expr{\Gamma}{\apply{\forall\alpha_L . A}{e}{C}}{\Delta}}$ [green]+∀App+
   $\quad\quad$
   $\frac{\expr{\Gamma}{e \Leftarrow A}{\Delta}}{\expr{\Gamma}{\apply{A \rightarrow C}{e}{C}}{\Delta}}$  [green]+→App+
   $\quad\quad$
>| $\text{apply} :: \Gamma \rightarrow e \rightarrow A \rightarrow (\Delta,\ [(L,\ B)\])$
|===

[bibliography]
== References

bibliography::[]
